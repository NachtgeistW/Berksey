---
title: 盐酸的C++基础知识小讲堂——lambda 表达式入门
category: 
- C++
tag: 
- C++
- lambda表达式
- Python
---
真实基础知识，真实讲堂

以下笔记摘自 D.N.Code 群聊天记录

<!-- more -->

首先来看维基百科的 Perm 算法的实现。

```C++
explicit perm(const int l = 0, function<void(vector<int>&)> fun = [](vector<int>&) {}) : 
len(l), used(l, -1), position(l), action(std::move(fun)) {}

...

perm p(len, [&](vector<int>& vec)
  {
   for (int i = 0; i < len; i++)
    cout << vec[i] << " ";
   cout << endl;
  });
```

这一堆东西是什么？？？

> 建议去看一下lambda表达式（  
——盐酸

之后 jy 提问“`[&](vector<int>& vec)` 是什么，为什么要用，要怎么用”。由此引出盐酸的 C++ 基础小知识讲座之 lambda 表达式。

## lambda 表达式

### 什么是 lambda 表达式

lambda 表达式是 C++11 起加入的新功能。它构造[闭包](https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))，能够捕获作用域中的变量的无名函数对象。换句话说，可以将 lambda 表达式理解成**一个没有名字的内联函数**。

一个完整的 lambda 表达式长这样：

```C++
[ 捕获 ] <模板形参>(可选)(C++20) ( 形参 ) 说明符(可选) 异常说明 attr -> ret requires(可选)(C++20) { 函数体 }
```

还有以下写法：

```C++
[ 捕获 ] ( 形参 ) -> ret { 函数体 }
[ 捕获 ] ( 形参 ) { 函数体 }
[ 捕获 ] { 函数体 }
```

不管忽略什么，`[]` 和函数体都永远不可少。其中， `[]` 是用来捕获不属于 lambda 表达式的变量的，即外部变量。如果留空，就代表 lambda 表达式不捕获外部变量。可以在 `[]` 里加变量名、 `&` 或者 `=`，这样就能捕获外部变量了。

假设有一个外部变量名为 `a`。`[a]` 意为使用**值捕获**的方式捕获它，`[&a]` 意为使用**引用捕获**的方式捕获它。跟函数的值传递和引用传递一样。

加 `&` 或者 `=` 的两种做法叫做隐式捕获，由编译器自己去推断要捕获的变量。`[&]` 的意思是，如果编译器发现 lambda 函数体里面有编译器不认识的东西，那编译器就到外面那层去找有没有叫这个名字的，如果有就**引用捕获**它。`[=]` 则是把引用捕获改成**值捕获**。

如，

```C++
std::vector<int> c = {1, 2, 3, 4, 5, 6, 7};
std::for_each(c.begin(), c.end(), [](int i){ std::cout << i << ' '; });
//1 2 3 4 5 6 7 
```

这就定义了一个匿名函数，参数是 `int i`，作用是输出 `i`+空格。这个 lambda 表达式的 `[]` 是空的，说明它不捕获外部变量。

而

```C++
void print_plus_x(const std::vector<int>& v, const int x)
{
   std::for_each(v.begin(), v.end(),
        [x](const int i){ std::cout << i + x << ' '; });
}
//2 3 4 5 6 7 8 
```

则显式捕获了外部变量 `x`。

```C++
void print_plus_x(const std::vector<int>& v, const int x)
{
   std::for_each(v.begin(), v.end(),
        [&](const int i){ std::cout << i + x << ' '; });
}
//2 3 4 5 6 7 8 
```

把 `[x]` 改成 `[&]` 之后运行，结果与写成 `[x]` 一致。这就是引用隐式捕获。

另外需要注意的是，当混合使用显式捕获和隐式捕获的时候，捕获列表的第一个元素必须是一个 `&` 或者 `=`。

### 捕获 (capture) 是什么？x 和 i 的区别在哪

> capture 的意思就是把这个函数体外面的东西捕获进来使用。  
> ——盐酸

x 和 i 的区别在于，i 是 lambda 表达式自己的参数；而 x 不属于 lambda 表达式，它是外部变量，是 lambda 表达式所在函数定义的局部变量。

### 为什么要用 lambda 表达式

> 所以，你懒得对这个“事情”定义一个专门的函数，然后就 inline 定义一个函数。  
> ——jy

> 比如说你懒得定义一个函数名的时候。因为这玩意就用一遍，也很简单，所以一个 lambda 比较简洁。  
> ——夜轮

> 比如你想搞一个函数，输入一个 vector 和一个 x，输出 vector 里每个元素 + x，那你这里 for_each 的第三个参数就是那玩意。因为 x 不是参数，i 才是那个参数，for_each 想要的函数是接受一个参数的，他只往函数里面传那个 i 进去，但是你又想在函数体里面用到 x，那就把 x 抓进函数体里面。  
>——盐酸

> 对于那种只在一两个地方使用的简单操作，lambda 表达式是最有用的。如果要在很多地方使用相同的操作，或者一个操作需要很多语句才能完成，通常建议使用函数。  
> ——《C++ Primer Plus》

---

## 对 Perm 函数的完整解释

以下是对开头 Perm 函数的完整解释。

> 类模板 std::function 是通用多态函数封装器。  
std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。  
—— cppreference

> 就是一个构造函数两个参数，一个 int 一个回调函数。  
`function<void(vector<int>&)> a = [](vector<int>&) {})` 是回调函数。  
fun 的默认值是一个符合这个 signature 的空函数。  
`std::function<Res(Arg...)>` 就是一个可以保存任何“参数类型是 Arg... 返回类型是 Res 的可以调用的东西的类”。  
`[](vector<int>&){}` 是一个参数为 `vector<int>&` 的空函数。`len(l), used(l, -1), position(l), action(std::move(fun))` 就是构造函数初始值列表。  
这里先值传递 function 再 move 进去是构造函数常用的一种方法。  
——盐酸

---

## 延伸

以下是盐酸讲 high 了的延伸部分。

> C++ 的 lambda 表达式跟其他很多语言不同之处在于 C++ 的 lambda 是 0 overhead 的（（（就是无额外开销
>
> 大部分语言的lambda都是类似这个 `&`（并且自带 type erasure，这里就有 runtime overhead 了）。为什么会有 overhead 呢，type erasure 必定带来 overhead，因为 type erasure 的目的是把所有返回值是 `Res` 而参数是 `Arg...` 的东西都擦除成同一个类型。这就必定需要到堆上申请空间，因为捕获的变量不同所需要的空间也就不同，然而同一个类型在栈上的空间是相等的。  
>
> py 那个 lambda 严重缩水，那个叫 list comprehension（  
> py那个函数定义本身就是个 closure
>
> ```Python
> def plus(x, y):
>    def plus_x(v):
>        return v + x
>    return plus_x(y)
> ```
>
> 比较心把但是应该懂我意思，就是 py 的函数自动捕获外面的变量（
>
> py 所有函数都捕获外部变量，C++ 那个例子如果你中括号里没有 x 的话是会编译错误的（（（（  
> 他就是原地定义了一个匿名的类，那个 lambda 是这个类的一个对象

注：

- type erasure：类型擦除，指在编译期明确去掉所编程序（某部分）的类型系统
- runtime overhead：运行时开销
- list comprehension：递推式构造列表

以下是锦鳞的一个问题。

> 我记得lambda表达式不完全等于匿名函数，那区别在哪（（

好问题，留待日后解决。
